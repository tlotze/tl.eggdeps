======================================
Printing a plain text dependency graph
======================================

First, let's set up some stuff we're going to need:

>>> from tl.eggdeps.plaintext import print_graph

>>> def pt_options(**kwargs):
...     options = dict(version_numbers=False,
...                    once=False,
...                    terse=False)
...     options.update(kwargs)
...     return Options(**options)

Now we populate a custom working set and compute its dependency graph,
arranging for one subtree to appear more than once in the graph:

>>> anton_1 = make_dist("anton-1.egg", depends="""berta
...                                               charlie[extra]""")
>>> berta_2 = make_dist("berta-2.egg", depends="charlie")
>>> charlie_1_4 = make_dist("charlie-1.4.egg", depends="""[extra]
...                                                       dora""")
>>> dora_0_5 = make_dist("dora-0.5.egg")
>>> ws = make_working_set(anton_1, berta_2, charlie_1_4, dora_0_5)

>>> from tl.eggdeps.graph import Graph
>>> graph = Graph(working_set=ws)
>>> graph.from_working_set()
>>> sprint(graph)
{'anton': {'berta': set([]), 'charlie': set([])},
 'berta': {'charlie': set([])},
 'charlie': {'dora': set(['extra'])},
 'dora': {}}


Full trees
==========

Full trees are still somewhat abbreviated representations of the complete
dependency structure but include enough information to reconstruct the latter:
they spell out recurring subtrees only the first time they occur but print the
subtree root distributions in all other places and add ellipses to hint at
omissions.

>>> print_graph(graph, pt_options())
anton
    berta
        charlie ...
    charlie
      [extra]
        dora

Version numbers may be printed next to the distribution names. Since this is
completely independent of all other options, we may as well demonstrate it
here:

>>> print_graph(graph, pt_options(version_numbers=True))
anton 1
    berta 2
        charlie 1.4 ...
    charlie 1.4
      [extra]
        dora 0.5


Printing each distribution only once
====================================

In order to shorten the representation, repeated occurrences of distributions
may be suppressed so that each distribution is printed only once. This
suppresses root distributions of omitted subtrees. Hints at omissions are
still printed so even though the information printed is no longer enough to
reconstruct the full tree from the output, one at least knows where something
is missing.

>>> print_graph(graph, pt_options(once=True))
anton
    berta
        ...
    charlie
      [extra]
        dora


Terse output
============

Terse output omits hints at left-out subtrees, such as ellipses:

>>> print_graph(graph, pt_options(terse=True))
anton
    berta
        charlie
    charlie
      [extra]
        dora


Xmas tree configuration
=======================

Finally, we switch on all options at once:

>>> print_graph(graph, pt_options(once=True,
...                               terse=True,
...                               version_numbers=True))
anton 1
    berta 2
    charlie 1.4
      [extra]
        dora 0.5


Determining which occurrence of a subtree to render
===================================================

If a subgraph of the dependency structure occurs multiple times, a
deterministic algorithm is employed to decide at which point in the printed
tree the subgraph is to be rendered.

A subgraph will be rendered as close to the root as possible in order to avoid
printing a deep tree:

>>> anton = make_dist("anton-1.egg", depends="""berta
...                                             charlie""")
>>> berta = make_dist("berta-2.egg", depends="charlie")
>>> charlie = make_dist("charlie-1.4.egg", depends="dora")
>>> dora = make_dist("dora-0.5.egg")
>>> ws = make_working_set(anton, berta, charlie, dora)
>>> graph = Graph(working_set=ws)
>>> graph.from_specifications("anton")
>>> print_graph(graph, pt_options())
anton
    berta
        charlie ...
    charlie
        dora

In particular, this prevents infinite recursion with cyclic dependency graphs:

>>> anton = make_dist("anton-1.egg", depends="anton")
>>> ws = make_working_set(anton)
>>> graph = Graph(working_set=ws)
>>> graph.from_specifications("anton")
>>> print_graph(graph, pt_options())
anton
    anton ...

If a subgraph can be reached from a root node both by a route consisting only
of mandatory dependency edges and by a route including extra dependencies, the
subgraph will be rendered at the point reached without considering extras:

>>> anton = make_dist("anton-1.egg", depends="""berta
...                                             [extra]
...                                             charlie""")
>>> ws = make_working_set(anton, berta, charlie, dora)
>>> graph = Graph(working_set=ws)
>>> graph.from_specifications("anton[extra]")
>>> print_graph(graph, pt_options())
anton
    berta
        charlie
            dora
  [extra]
    charlie ...

However, if a distribution is required more than once with different sets of
extras, the dependencies of all extras involved will be rendered at the same
occurrence of that distribution:

>>> anton = make_dist("anton-1.egg", depends="""berta
...                                             charlie""")
>>> berta = make_dist("berta-2.egg", depends="charlie[foo]")
>>> charlie = make_dist("charlie-1.4.egg", depends="""dora
...                                                   [foo]
...                                                   emil""")
>>> dora = make_dist("dora-0.5.egg")
>>> emil = make_dist("emil-1.egg")
>>> ws = make_working_set(anton, berta, charlie, dora, emil)
>>> graph = Graph(working_set=ws)
>>> graph.from_specifications("anton")
>>> print_graph(graph, pt_options())
anton
    berta
        charlie ...
    charlie
        dora
      [foo]
        emil


Regressions
===========

In version 0.3.1, a bug involving omissions in the plaintext output was found:
If a subtree was omitted, siblings following its mount point were skipped.
This is how it should work:

>>> anton = make_dist("anton-1.egg", depends="""berta
...                                             charlie""")
>>> berta = make_dist("berta-2.egg", depends="""charlie
...                                             emil""")
>>> charlie = make_dist("charlie-1.4.egg", depends="dora")
>>> dora = make_dist("dora-0.5.egg")
>>> emil = make_dist("emil-1.egg")
>>> ws = make_working_set(anton, berta, charlie, dora, emil)
>>> graph = Graph(working_set=ws)
>>> graph.from_specifications("anton")

>>> print_graph(graph, pt_options())
anton
    berta
        charlie ...
        emil
    charlie
        dora

>>> print_graph(graph, pt_options(once=True))
anton
    berta
        emil
        ...
    charlie
        dora

>>> print_graph(graph, pt_options(terse=True))
anton
    berta
        charlie
        emil
    charlie
        dora


.. Local Variables:
.. mode: rst
.. End:
